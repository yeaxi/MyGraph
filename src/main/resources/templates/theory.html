<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Теорія</title>

    <!-- Bootstrap core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">


    <!-- Custom styles for this template -->
    <link href="/css/blog.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

<!--navigation-->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar"
                    aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" th:href="@{/}">Головна</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
                <li><a th:href="@{/theory}">Теорія</a></li>
                <li><a th:href="@{/instruction}">Інструкція</a></li>
                <li><a th:href="@{/about-developer}">Про розробника</a></li>
                <li><a th:href="@{/description}">Про програму</a></li>
            </ul>
        </div>
    </div>
</nav>
<!--end navigation-->
<div class="container">

    <div class="blog-header">
        <h1 class="blog-title">Алгоритм Дейкстри</h1>
        <p class="lead blog-description">Граф. Алгоритм роботи</p>
    </div>

    <div class="row">

        <div class="col-sm-11 blog-main">

            <div class="blog-post">
                <h2 class="blog-post-title">Граф</h2>
                <!--<p class="blog-post-meta">January 1, 2014 by <a href="#">Mark</a></p>-->

                <p>Граф — це сукупність об'єктів із зв'язками між ними.</p>
                <hr>
                <p>Об'єкти розглядаються як вершини, або вузли графу, а зв'язки — як дуги, або ребра. Для різних
                    областей використання види графів можуть відрізнятися орієнтовністю, обмеженнями на кількість
                    зв'язків і додатковими даними про вершини або ребра.
                </p>
                <blockquote>
                    <p>Велика кількість структур, які мають практичну цінність в математиці та інформатиці, можуть бути
                        представлені графами. Наприклад, будову Вікіпедії можна змоделювати за допомогою орієнтованого
                        графу, в якому вершини — це статті, а дуги (орієнтовані ребра) — посилання на інші статті.
                    </p>
                </blockquote>
                <p>Першою працею з теорії графів як математичної дисципліни вважають статтю Леонарда Ейлера (1736), у
                    якій розглядалася задача про Кенігсбергські мости. Наступний імпульс теорія графів отримала близько
                    100 років потому з розвитком досліджень по електричних мережах, кристалографії, органічній хімії та
                    іншим наукам.</p>

                <h2>Визначення</h2>
                <p>Теорія графів не має стійкої термінології. В різних статтях під одними й тими ж термінами розуміють
                    різні поняття. Наведені нижче визначення є одними з найбільш розповсюджених.</p>
                <h3>Граф</h3>
                <p>Граф або неорієнтований граф G — це впорядкована пара G:=(V,E), для якої виконуються наступні умови:
                    V — множина вершин або вузлів,
                    E — множина пар (у випадку неорієнтованого графу — невпорядкованих) вершин з V, які називають
                    ребрами.
                    V (і так само E) зазвичай вважаються скінченними множинами.
                    Велика кількість результатів, отриманих для скінченних графів, невірна (або інша) для нескінченних
                    графів. Це пов'язано з тим, що певний набір ідей стає хибним у випадку нескінченних множин.</p>
                <pre>
                    <img style="float: left;"
                         src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Undirected.svg/188px-Undirected.svg.png">
                    <img style="float: right;"
                         src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Directed.svg/188px-Directed.svg.png">
                </pre>
                <h3>Орієнтований граф</h3>
                <p>Граф, який містить тільки ребра називається неорієнтованим, який містить тільки дуги — орієнтованим.
                    Граф, що має як ребра так і дуги, називається мішаним. Якщо пара вершин сполучається кількома
                    ребрами чи дугами одного напрямку, то ребра (дуги) називають кратними (паралельними). Дуга чи ребро,
                    що сполучає вершину саму із собою називається петлею. Граф без кратних дуг і петель називається
                    простим.
                    Вершини сполучені ребром чи дугою називають суміжними, також називають суміжними ребра, що мають
                    спільну вершину.
                    Кожен граф можна відобразити в евклідовому просторі множиною точок, які відповідають вершинам,
                    сполучених лініями, що відповідають ребрам (дугам).</p>
            </div>
            <!-- /.blog-post -->

            <div class="blog-post">
                <h2 class="blog-post-title">Алгоритм Дейкстри</h2>
                <!--<p class="blog-post-meta">December 23, 2013 by <a href="#">Jacob</a></p>-->

                <p>Будь-яка задача, що вимагає знаходження оптимальних маршрутів може бути виконана за допомогою
                    алгоритму Дейкстри. Це стосується і мереж, і транспортних потоків, і обробка графів. Дуже часто
                    використовується не сам алгоритм в чистому вигляді, а його модифікація.</p>
                <blockquote>
                    <p> Класичний алгоритм Дейкстри працює тільки для графів без циклів від'ємної довжини.</p>
                </blockquote>

                <p>Постановка завдання на максимум виглядає наступним чином:</p>
                <p>
                    Нехай дано граф G=(Х, Г), дугам якого приписані ваги (вартості довжини), що задаються матрицею
                    С=[cij].

                    Завдання полягає в знаходженні найкоротшого шляху від заданої початкової
                    вершини s? x до заданої кінцевої вершини t? x, за умови, що такий шлях існує t? R (s) (тут R (s) -
                    безліч, досяжна з вершини s) і всі цикли в графі мають позитивну сумарну вагу. Бо якщо в графі
                    буде присутній цикл з негативним сумарною вагою та хi - деяка його вершина, то, рухаючись від s до
                    хi, обходячи цей цикл досить багато раз і потрапляючи, нарешті в t, вийде шлях з як будь-якою малою
                    вагою. Таким чином, в цьому випадку найкоротшого шляху не існує. Так що неорієнтовані ребра графа G
                    не можуть мати негативну вагу.

                </p>
                <p>Процедура знаходить шлях мінімальної ваги в графі G=(V, E) заданому ваговій матриці W у якої елемент
                    дорівнює вазі ребра, що з'єднує i-ую і j-ую вершини. При цьому передбачається, що всі елементи wij
                    ненегативні. Шлях шукається з вершини номер u1 до вершини номер u2. Процедура використовує алгоритм
                    Дейкстри. Для представлення ваги, рівного нескінченності, використовується число GM, передане в
                    алгоритм. Це число можна задавати залежно від конкретного завдання.

                    Алгоритм по якому відбувається пошук полягає в наступному:
                </p>
                <ul>
                    <li> Всім вершин приписується вага - дійсне число, d (i):=GM для всіх вершин крім вершини з номером
                        u1, а d (u1):=0.

                    <li> Всім вершин приписується мітка m (i):=0.</li>

                    <li> Вершина u1 оголошується поточної: t:=u1.</li>

                    <li> Для всіх вершин які m (i) дорівнює 0, перераховуємо вагу за формулою d (i):=min {d (i), d (t) +
                        W [t, i]}.
                    </li>
                    <li>Серед вершин для яких виконано m (i)=0 шукаємо ту для якої d (i) мінімальна, якщо мінімум не
                        знайдений, тобто вага всіх не помічених вершин дорівнює нескінченності, то шлях не існує,
                        покидаємо алгоритм
                    </li>
                    <li>Інакше знайдену вершину c мінімальною вагою вважаємо поточної та помічаємо (m (t):=1)</li>
                    <li>Якщо t=u2, то знайдено шлях ваги d (t), покидаємо алгоритм і переходимо на наступний крок</li>
                </ul>
            </div><!-- /.blog-post -->

        </div><!-- /.blog-main -->

    </div><!-- /.row -->

</div><!-- /.container -->

<footer class="blog-footer">
    <p>Довідка для курсового проекту</p>
    <p>
        <a th:href="@{/theory}">Повернутись до початку сторінки</a>
    </p>
</footer>


<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
</body>
</html>